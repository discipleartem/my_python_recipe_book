Python

 Расширение файлов .py


 Установка с офф айта https://www.python.org/downloads/

 ! ставим галку "Add to system PATH"
 ! ставим галку с IDLE (питоновская консоль)
 ! в Ubuntu питон стоит по умолчанию

 Запуск программы с обычной командной строки:
 $ python python_programm_name.py (сперва перейти в директорию с программой)



О языке:

- низкий порог входа
- динамическая типизация
- приоритет в web разработке
- полиморфный
- многопоточность
- ядро CPython (дефолтное) на С
- открытый исходный код
- отступ в 4 пробела

====================================================================

How to DEBUG

    #показывает все доступные методы объекта
    print(dir(object))

    #переопределяем метод str

    def __str__(self):
        return '{}'.format(self.title)





====================================================================
Структура:


Package    #(пакеты)

    module  #(модуль)

        class Classs

            def function():  #(метод, функция)
                my_variable = 1
                pass

====================================================================
cохранение зависимостей как bundle в ruby
    # pip freeze > requirements.txt (лучше не использовать ибо тянет глобальные зависимости)
    pip freeze --local > requirements.txt

Загрузка зависимостей как bundle install в ruby
    pip install -r requirements.txt
----------------------------------------
Если вы используете ОС Windows:
    python -m pip install -U pip setuptools

--------------------------------------------
    Лучше всего смотреть в INSTALLED_APPS и выковыривать всё вручную. С pip freeze есть вариант получить тыкву через некоторое время, ибо он вытягивает абсолютно все пакеты вместе с их зависимостями (включая системные), а пакеты со временем обновляются, старые версии удаляются. 
    Да и нечего вам рулить зависимостями вручную - это задача менеджера пакетов (pip или easy_install).

    Лучше всего заполнять файл requirements по мере написания проекта, а не после.
    Добавлено: Есть подходящая опция у pip: pip freeze --local
    Из справки: If in a virtualenv that has global access, do not output globally-installed packages.

====================================================================

«The Zen of Python» Философия:

!    Красивое лучше, чем уродливое.
!    Явное лучше, чем неявное.
!    Простое лучше, чем сложное.
    Сложное лучше, чем запутанное.
    Плоское лучше, чем вложенное.
    Разреженное лучше, чем плотное.
!    Читаемость имеет значение.
!    Особые случаи не настолько особые, чтобы нарушать правила.
!    При этом практичность важнее безупречности.
!    Ошибки никогда не должны замалчиваться. Если не замалчиваются явно.
    Встретив двусмысленность, отбрось искушение угадать.
!    Должен существовать один — и, желательно, только один — очевидный способ сделать это.
    Хотя он поначалу может быть и не очевиден, если вы не голландец[12].
!    Сейчас лучше, чем никогда. Хотя никогда зачастую лучше, чем прямо сейчас.
!    Если реализацию сложно объяснить — идея плоха. Если реализацию легко объяснить — идея, возможно, хороша.
    Пространства имён — отличная штука! Будем делать их побольше!




    Выписка из «Styleguide for Python Code»:
        https://drive.google.com/file/d/0B7cDWj1-Z0r0MmYwZjJhZWEtMjk1Zi00NWE5LWEzNTQtOTFjNjcwYjdhMGRl/view?ddrp=1&hl=ru#

    - 4 пробела на один уровень отступа.
    - максимальную длину строки 79 символами.
    - переноса длинных строк предпочтительнее через скобки (где явно видно что это продолжение),
        но красивее через обратный слеш  "\" :

        class Rectangle(Blob):
            def __init__(self, width, height,
                     color='black', emphasis=None, highlight=0):
                if width == 0 and height == 0 and \
                            color == 'red' and emphasis == 'strong' or \
                highlight > 100:
                    raise ValueError("sorry, you lose")

    - Отделяйте функции (верхнего уровня, не функции внутри функций) и определения классов двумя пустыми строчками.
    - Определения методов внутри класса отделяйте одной пустой строкой.
    - Начиная с версии python 3.0, предпочтительной является кодировка UTF-8
    - Пробелы в выражениях и инструкциях:

        можно:
            spam(ham[1], {eggs: 2})

        нельзя:
            spam( ham[ 1 ], { eggs: 2 } )

        можно:
            spam(1)

        нельзя:
            spam (1)

        можно:
            dict['key'] = list[index]

        нельзя:
            dict ['key'] = list [index]


    - Использование более одного пробела вокруг оператора присваивания (или любого другого) для
того, чтобы выровнять его с другим таким же оператором на соседней строке:

        можно:
            x = 1

            y = 2

            long_variable = 3


        нельзя:
            x             = 1

            y             = 2

            long_variable = 3

    - Вседа окружайте эти бинарные операторы одним пробелом с каждой стороны: присваивание (=,
        +=, -= и прочие), сравнения (==, <, >, !=, <>, <=, >=, in, not in, is, is not), логические
        операторы (and, or, not).

    - Не используйте составные инструкции (несколько команд в одной строке).

        можно:
            if foo == 'blah':

            do_blah_thing()

            do_one()

            do_two()

            do_three()


        нельзя:
            if foo == 'blah': do_blah_thing()

            do_one(); do_two(); do_three()


    - Комментарии должны являться законченными предложениями. Если комментарий — фраза или
        предложение, первое слово должно быть написано с большой буквы, если только это не имя
        переменной, которая начинается с маленькой буквы (кстати, никогда не отступайте от этого
        правила для имен переменных).Ставьте два пробела после точки в конце предложения.


    - Блоки комментариев: Каждая строчка такого блока должна начинаться с символа "#" и одного пробела
        после него (если только сам текст комментария не имеет отступа).

    - Никогда не используйте символы l (малелькая латинская буква «эль»), O (заглавная латинская
        буква «о») или I (заглавная латинская буква «ай») как однобуквенные идентификаторы.
        В некоторых шрифтах эти символы неотличимы от цифры один и нуля (и символа вертикальной
        палочки, — прим. перев.) Если очень нужно использовать l имена, пишите вместо неё заглавную L.

    - Модули должны иметь короткие имена, состоящие из маленьких букв. Можно использовать и
        символы подчеркивания, если это улучшает читабельность. То же, за исключением символов
        подчеркивания, относится и к именам пакетов.

    - Все имена классов должны следовать соглашению CapWords почти без исключений. Классы внутреннего
        использования могут начинаться с символа подчеркивания.

    - имена для функций и переменных glob_var (с маленькой и разделены "_" )

    - конкатенация строк ("стока1" + "строка2") используйте ''.join() — таким образом склеивание строк будет выполнено за линейное время
        независимо от реализации python.

    - Сравнения с None должны обязательно выполняться с использованием операторов is или is not,
        а не с помощью операторов равенства или неравенства. Кроме того, не пишите if x, если имеете в
        виду if x is not None — если, к примеру, при тестировании такая переменная или аргумент примет
        значение иного типа, то при приведении к булевскому типу получится False.


    -



------------------------------------------------------------------------------------------------------------------
Переменные:

    В Python переменные являються не объектом а ссылкой на объект (вроде как в руби). В теории две разных переменных
        могут изменять 1 и тот же объект.
        Пример:
            >>> x = []
            >>> y = x
            >>> y.append(10)
            >>> y
            [10]
            >>> x
            [10]

        Почему изменение списка 'y' изменяет также список 'x'? Два факта приводят к такому результату:
            * Переменные - это просто ссылки на объекты. y = x не создаёт копию списка - это просто создаёт переменную y,
                         которая ссылается на тот же объект, что и x.
            * Списки изменяемы.

    x (global x, в основном коде)        - глобальная переменная

    x (внутри функции)                   - локальная переменная

    nonlocal x (функция внутри функции)  - "nonlocal"

    __somevariable__                     - константа ?

------------------------------------------------------------------------------------------------------------------





    dir([object]) - Список имен объекта, а если объект не указан, список имен в текущей локальной области видимости.

    MAX_OVERFLOW, TOTAL # Константа обычно объявляются на уровне модуля и записываются только заглавными буквами, а
                            слова разделяются символами подчеркивания.  MAX_OVERFLOW, TOTAL.

    global glob_var     # глобальная переменная
        globals() - Словарь глобальных имен

    local_var           # обычная локальная

    _in_var              # внутреняя переменная класа/функции


типы данных:
    int       - число, любое в python 3
        bool  - True/False, 1/0, наследован от int
        float = duble - число с плавающей запятой
            Пример: 5 + True  - выведет 6, потому что True = 1



    str       - строка. Строки неизменяемы. Cтроки в двойных кавычках и в одинарных эквивалентны,
                и ничем друг от друга не отличаются.
    tuple     - кортеж
    list      - список

    None      - my_none_variable = None. Проверять на "None" нужно через оператор "is",
                а не через  "=="

    from collections import namedtuple                                  #в Python 2 можно было создавать именнованые кортежи
        Person = namedtuple("Person", "name surname age")
        person = Person(name='Max', surname='Usachev', age='25')
        person = Person('Max', 'Usachev', '25')

        person.name  person.age

массивы:

!!! Помните, что в Python нумерация начинается с 0, а не с 1.

    список:
        spisok = [1, "1", a, abc]        # изменяеться
        spisok = []                      # преобразуем переменную spisok в список ;)



    кортеж (неизменяемый список):
        kortej = (1, "1", a, abc)       # НЕизменяемый, быстрее и экономнее
        kortej = tuple("Hello")         # функция превращает в кортеж, при этом разбивая строку на элементы

    словарь:
        dictionary = {'test' : 45, 'ключ2' : 'Hi!', 'key3' : 1212}      # словарь = ассоциативный масив "ключ : значение"
        dic = dict(key1='Hello', key2=12323)                            # альтернативная запись словаря
        print(dictionary['key3'])                                       # вывод элемента с ключом 'key3'

        dic2 = dict.fromkeys(['a', 'b', 'c'], 'значение1')               # альтернативый способ создание словаря с множеством ключей
                                                                         # и значением 'значение1' (можно списком/перечислением) для
                                                                         # каждого ключа будет одни и теже значения

    множество:
        mnojestvo = set("hello")                # создаст массив типа ['h', 'o', 'e', 'l'] без второго 'l'.
                                                # Тоесть без повторений и рандомно
        mnojestvo2 = {'asd', ab, 231434}        # Альтернативная запись множества (без повторений и рандомно)

        neizmen_mnoj = frozenset("Aloha!")      # Создает НЕизменное множество (быстрее и экономнее)



    и другие



методы работы с массивами:

        spisok.append('HI!')        # добавляет в конец массива значение
        spisok.insert(1, 9)         # добавляет на 2-е место элемент "9" сдвигая при этом имеющийся элемент

        del spisok[3]               # удаляет элемент массива по индексу
        spisok.remove(0)            # удаляет из списка 1 эл. массива

        spisok[2] = 5               # изменяет 3й элемент масива на значение 5

        for element in spisok:      # при работе со списками используют цикл "for"
            print len(element,
                "всего элементов в "
                 "списке")





    print(spisok.index('HI!'))  # выводит индекс элемента 'HI!'

    print(spisok[-1])           # выводит 2-й с конца элемент

        8 in spisok             # выдает True/False если есть/нету данного элемента в массиве
        len(spisok)             # выдает количество элементов в списке

    new_list = my_list[start:end(+1):step]      # Можно отсортировать/срезать список такой записью


    my_list = [1, 2, 3, 4]
        my_list[:]              # Возвращает копию списка my_list
        my_list2 = my_list      # Создаст только дополнительную ссылку на объект а не скопирует его
        my_list2 = my_list[:]   # Сделает копию объекта списка my_list

    print(spisok[2:-3:4])           #  2 - номер элемента с какого начинаеться сортировка,
                                    # -3 - на с 4-го с конца элемента идет пропуск,
                                    #  1 - шаг в 4 хода. Если не указывать то шаг в 1 по уполчанию



Операции с числами:

    int(x)          - преобразовать в целое число
    float(x)        - преобразовать в вещественное число (число типа 1.01 ?)
    x**y            - х в степени у
    round(x,n)      - круглить действительное число х (до n цифр после запятой, если n указано)
------------------------------------
    import math
        math.trunc(x)        - отрезает все после . (1.94234) до целого (1)
------------------------------------


Операторы:

Набор операторов достаточно традиционен.

    Условный оператор if (если). Альтернативный блок после else (иначе).
        Если условий и альтернатив несколько, можно использовать elif (сокр. от else if).

    Операторы цикла while (пока) и for (для).
        Внутри цикла возможно применение break и continue для прерывания цикла и перехода сразу к следующей итерации, соответственно.

    Оператор определения класса class.

    Оператор определения функции, метода или генератора def.
        Внутри возможно применение return (возврат) для возврата из функции или метода,
        а в случае генератора — yield (давать).
        Функции внутри функции наз. рекурсивными. При больших вычислениях они зависают потому что некуда сохранять результаты.
            для обхода этого можно прописать:
                import functools

                @functools.lru_cache(maxsize=None)
                сохраняет все вычисления рекурсии в кеше

        type(perenennaya)     # Проверка на тип переменной

    Оператор обработки исключений try — except — else или try — finally
        (начиная с версии 2.5, можно использовать finally, except и else в одном блоке).

    Оператор pass ничего не делает. Используется для пустых блоков кода.


Сравнения:

x = True
y = False

    * оператор "and"    - выдаст False
    * оператор "or"     - выдаст True
    * оператор "not" x  - выдаст False (инвентирует показание переменной/объекта)
    * x is y            - х и у - это оди и тот же объект (id) (выдаст True)
    * x is not y        - х и у не являються одним и тем же объектом в памяти (выдаст True)

Логические операции:
    x or y      - если х - ложь, то у, иначе x
    x and y     - если х - ложь, то х, иначе у
    not x       - если х - ложь, то True, иначе False

    Приоритет: сначала 'not' , 'and' , 'or'



Рабо со строками:
    string = "first line. " \
             "Second line."    - все в 1 строку

    string = "first line. \n" \
                 "Second line." -  c помощью "\n" мы перенесли строку.

    string = "first line. \\" \
                 "Second line." - для того чтобы в тексте был "\", нужно написать бекслеш два раза "\"

    multiline_string = """ Lesson 2
        - 1
        -2
        3
            save all spaces
    """                         - 3 двойные и 3 одинарные кавычки вначале и вконце сохраняют форматирование теста внутри со всеми пробелами

   'A' + 'string'              - будет "A string". "+" конкатенирует строки (слогает)
   'zapat\'aya v texste'       - c помощью экранирования " \' " можно добавить запятую в тексте
   'number = {}'.format(17) - форматирование внутри строки (переменная)



 "=", "=="          - используют для сравнения значений
 "is", "is not"     - используют для сравнения объектов (id = id)

     - Сравнения с None должны обязательно выполняться с использованием операторов is или is not,
        а не с помощью операторов равенства или неравенства. Кроме того, не пишите if x, если имеете в
        виду if x is not None — если, к примеру, при тестировании такая переменная или аргумент примет
        значение иного типа, то при приведении к булевскому типу получится False.

------------------------------------------------------------------------------------------------------------
Регулярные выражения:
    Формат регулярных выражений унаследован из Perl с некоторыми отличиями.
        Для их использования, требуется импортировать модуль re, являющийся частью стандартной библиотеки.
------------------------------------------------------------------------------------------------------------

циклы:
    1. с предусловием:                   #проверка в начале цикла(итерации)
        while условие:
            операторы
            pass

        while True:                     # бесконечный цикл
            print(n)
            n += 1
            pass

        в цикле while можно использовать операторы
        "break"     - прерывает весь цикл
        "continue"  - прерывает текущую итерацию при выполнении условия
            while number < 10:
                number += 1
                if number == 5:
                    continue
                print('bla bla')    # При number == 5 print не выведеться


    2. с постусловием:                   #проверка в конце цикла(итерации)
        в Pythone нет циклов с постусловием
        # do ... while ()

    3. с счетчиком:
        for x in range(1,10):
            pass

    4. Совмеснтный цикл:
        #for each в других ЯП
        в Pythone это for с использованием range

        for a in range(конечное значение):
            операторы               # выведет с 0-9 включительно

        for a in range(начальное значение, конечное значение):
            операторы

        for a in range(начальное значение, конечное значение, шаг):
            операторы

        Начальное значение включаеться в диапазон, конечное - нет

Функции:

    def printMax(a, b):             # (а, b) это Параметры
        if a > b:
            print(a, 'максимально')
        elif a == b:
            print(a, 'равно', b)
        else:
            print(b, 'максимально')

    printMax(3, 4)                  # прямая передача значений. (3, 4) - аргументы

    # Параметры указываются в скобках при объявлении функции и разделяются запятыми.  \
    # Аналогично мы передаём значения, когда вызываем функцию. Обратите внимание на    \
    # терминологию: имена, указанные в объявлении функции, называются параметрами, то-  \
    # гда как значения, которые вы передаёте в функцию при её вызове, – аргументами.


    x = 50                      # тут х =

    def func():
        global x                # тут мы ссылаемся на х вне функции
                                # Если не писать "global" то функция создала бы свою переменную х

        print('x равно', x)

        x = 2                   # х уже = 2
        print('Заменяем глобальное значение x на', x)

    func()
    print('Значение x составляет', x)


    # Чтобы присвоить некоторое значение переменной, определённой на высшем уровне  \
    # программы (т.е. не в какой-либо области видимости, как то функции или классы), необ- \
    # ходимо указать Python, что её имя не локально, а глобально (global).



    def func_outer():                   # Пример функции внутри функции
        x = 2
        print('x равно', x)

        def func_inner():
            nonlocal x
            x = 5

        func_inner()

        print('Локальное x сменилось на', x)
    func_outer()

# Значения аргументов можно установить по умолчанию. Их \
# можно указать, добавив к имени параметра в определении функции оператор присваи- \
# вания (=) с последующим значением.

    def say(message, times = 1):        # как "times = 1"
        print(message * times)

    say('Привет')
    say('Мир', 5)



# Если имеется некоторая функция с большим числом параметров, и при её вызове тре- \
# буется указать только некоторые из них, значения этих параметров могут задаваться по \
# их имени – это называется ключевые параметры. В этом случае для передачи аргументов \
# функции используется имя (ключ) вместо позиции (как было до сих пор).


    def func(a, b=5, c=10):
        print('a равно', a, ', b равно', b, ', а c равно', c)

    func(3, 7)
    func(25, c=24)
    func(c=50, a=100)

$ python func_key.py

    a равно 3, b равно 7, а c равно 10
    a равно 25, b равно 5, а c равно 24
    a равно 100, b равно 5, а c равно 50




    def total(initial=5, *numbers, **keywords):
        count = initial
        for number in numbers:
            count += number
        for key in keywords:
            count += keywords[key]
        return count

        # Когда мы объявляем параметр со звёздочкой (например, *param), все позици- \
        # онные аргументы начиная с этой позиции и до конца будут собраны в кортеж \
        # под именем param.
        #
        # Аналогично, когда мы объявляем параметры с двумя звёздочками (**param), \
        # все ключевые аргументы начиная с этой позиции и до конца будут собраны \
        # в словарь под именем param.


    def total(initial=5, *numbers, extra_number):
    count = initial
    for number in numbers:
    count += number
        count += extra_number
        # Обратите внимание на использование +=, который представляет собой сокра- \
        # щённый оператор, позволяющий вместо x = x + y просто написать x +=y.
    print(count)

    total(10, 1, 2, 3, extra_number=50)   # правильно
    total(10, 1, 2, 3)                    # не правильно


    # Объявление параметров после параметра со звёздочкой даёт только ключевые \
    # аргументы. Если для таких аргументов не указано значение по умолчанию, и \
    # оно не передано при вызове, обращение к функции вызовет ошибку, в чём \
    # мы только что убедились.



Оператор «return» используется для возврата5 из функции, т.е. для прекращения её работы \
и выхода из неё. При этом можно также вернуть некоторое значение из функции.


    # Обратите внимание, что оператор return без указания возвращаемого значения эквива- \
    # лентен выражению return None. None – это специальный тип данных в Python, обознача- \
    # ющий ничего.

    Пример:

    def someFunction():
        pass
        # return None                # скрытый return, который стоит во всех ф-х по умолчанию.


Документирование:

    # Строки документации принято записывать в форме многострочной7 строки, \
    # где первая строка начинается с заглавной буквы и заканчивается точкой. Вто- \
    # рая строка оставляется пустой, а подробное описание начинается с третьей.
    # Вам настоятельно рекомендуется следовать такому формату для всех строк \
    # документации всех ваших нетривиальных функций.

    Пример:
        """Начало документации.
                                    # пустая строка
        И тут подробно описываем документацию. Описывает константы, переменные которые не стоит трогать.
        Как все настроить и как запустить."""


Параметры:

    fake = None

    def some_function(fake):        # "fake" - это формальный параметр
        print(fake)


    #some_function(fake)

    impotent = "olo-lo"
    some_function(impotent)         # "impotent" - это фактический параметр (аргумент), который заменяет формальный параметр


-------------------------------------------------------------------------------------------------------------------------------
Дата и Время

    Есть определенные затруднения в сохранении нужной даты на клиенте, сервере, бэке, БД
    Стандартная библиотека "datetime" работает с UTC
    https://habrahabr.ru/post/323608/ и коменты



    # Проблема в том, что вы не можете использовать модуль datetime python для создания даты рождения.

    # return datetime.date (bs_year, bs_month, bs_day)
    # Модуль datetime для python предназначен только для дат AD.
    # 2072-04-31 исключает исключение, потому что апрель (4-й месяц) всегда содержит 30 дней в AD.
    # В то время как 2072-04-31 является совершенно допустимой датой для даты рождения.

    import os
    # os.startfile(r'C:\Program Files (x86)\Microsoft Office\OFFICE11\WINWORD.EXE')

    from datetime import datetime

    # Альтернативная запись:
    #
    # from datetime import datetime, date
    # and then construct with date(y,m,d) (без "datetime." prefix).

    time_1 = datetime.now()
    print(time_1)

    time_2 = time_1.time()
    print(time_2)

    time_3 = dt.time(time_1.hour, time_1.minute, time_1.second)
    print(time_3)

    time_4 = dt.date(time_1.year, time_1.month, time_1.day)
    print("какого лешего я не могу написать дд/мм/гг, а должен ",
           "писать так ", time_4, "?")


    time_1 = now.year
    time_1 = now.month
    time_1 = now.day


    datetime.now() - объект текущей даты и времени              # без "from datetime import datetime"

    datetime.date() - объект даты (с отсечением времени).       # без "import datetime as dt" не работает

    datetime.time() - объект времени (с отсечением даты).       # без "import datetime as dt" не работает

    print('%s:%s:%s' % (time_1.hour, time_1.minute, time_1.second))   # приводит в нужный вид
    print('%s/%s/%s' % (time_1.day, time_1.month, time_1.year))       # приводит в нужный вид


    # В повседневной жизни, когда дробная часть секунд не важна,/
    # среднее время по Гринвичу (GMT) может рассматриваться как эквивалент UTC или UT1.
    # Следует помнить, что время по UTC не переводится ни зимой, ни летом. Поэтому для тех мест,/
    # где есть переход на летнее время, меняется смещение относительно UTC.
-------------------------------------------------------------------------------------------------------------------------------

Импорт

    импортировать лучше через:

        import library              # library.py в том же каталоге или в каталогах system.path

        from library import *      # Это импортирует все публичные имена, но не импортирует __version__, что может привести к
                                    # к переименованию ваших методов и переменных.
                                    # потому что оно начинается с двойного подчёркивания

        from mymodule import hren   # мпортирует только hren метод/переменную

        При импортировании модуля выполняеться весь код модуля типа циклы, вводы, выводы и прочее


Если писать файл librarу.py так:

    # тут пишем доступный код который будет импортироваться в другой модуль

    main_var1 = 1
    main_var2 = 2
    main_var3 = 3

    def kakaha (main_var1, main_var2, c = 0):
        while c >= 100
            a = main_var1
            b = main_var2
            c = a + b
            print(c + "/n")

    if __name__ == "__main__"

    # а тут мы пишем код который будет выполняться как скрипт с циклами, вводами, выводами и прочее

    secret_var1 = "secret_value"
    secret_var2 = "secret_value"
-------------------------------------------------------------------------------------------------------------------------------
Особенности
    - Python чуствительный к лишним пробелам/отступам
    - для выставления приоритета в вычислениях (может и не только) нужно использовать "()"
    - данные поступают в виде "строки" по умолчанию
    - True/False с большой
    - None, False, "пустая строка" по умолчанию считаються как False, все остальное как True
    - xrange в цикле for использовать в Python 2.xx


==============================================================================================================================
Система контроля версий (Git) для Windows
        Гайд - https://habrahabr.ru/sandbox/103344/

        Качаем git https://git-scm.com/downloads

        При установке Git под Windows вам нужно будет прописать git.exe в PATH вашей системы, чтобы Git можно было запускать из любого места в командной строке.

        1) Выбираем вариант "Use Git from the Windows Command Prompt" для того чтобы использовать Git из командной строки из любого каталога и не потревожите стандартные программы Windows find и sort

        2) Нужно предать значение "символам окончания строки". В Windows Linux и Mac разные символы окончания (не переноса, хотя и это тоже :р ) строки. Тоесть текстовый файл (в котором наш код) будет поврежден и ОС не сможет его прочитать/выполнить.
           Здесь мы указываем как Git будет поступать с символами окончания строк. На Windows и Linux эти символы разные и Git может менять их перед отправкой и получением кода из репозитория. В моём случае лучший выбор — это не вмешиваться в код при получении и следить за тем, чтобы в репозиторий не попадали файлы с символами Windows-style.

           "Checkout as-is, commit Unix-style line endings"


            При настройке вручную для Windows через терминал - git config --global core.autocrlf True

            autocrlf True – git при каждом коммите будет преобразовывать CRLF в LF и наоборот при чтении из репозитория. Таким образом в репозитории будет православный LF (формал Linux) а пользовательский редактор будет получит CRLF. Это сделано специально для Windows пользователей.

        3) Последний экран не столь важен, здесь можно указать что будет в основе надстройки Git Bush — стандартная консоль Windows или MinTTY. Если у вас Windows до 10 версии, то лучше выбрать MinTTY.

        4) После установки укажите Git ваше имя и электронную почту. Эти данные будут передаваться с каждым коммитом и их нельзя будет изменить.

            Откройте Git Bush и запустите две команды:

            git config --global user.name "Ваше_Имя" (Tomas)
            git config --global user.email Ваша_Электронная_Почта (discipleartem@gmail.com)

        5) Добавим ключи shh чтобы постоянно не вводить логин/пароль на коммиты
           Open Git Bash.

        - ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
            жмем enter раза 3-4

        - cat ~/.ssh/id_rsa.pub - копируем то что выдало и на гитХаб ставим
            Но долбаный Git bash нихрена не копирует и не вставляет в (из) консоль. Так что идем по пути из терминала (у меня C:\Users\User\.ssh и открываем файл id_rsa.pub).
            Копируем содержимое на сайт https://github.com/settings/profile
            Раздел SSH and GPG keys выбераем SSH. Называем наш ключ в тайтле типа Home/Work/Fun1

        - ssh -T git@github.com проверяем (прописываем yes)

        На этом первоначальная настройка Git закончена.


        6) Создам репозиторий с именем типа "test".

        7) при использовании "git-bash.exe" нужно прописывать путь с другими слешами
             типа cd d:/python_win/work/test_pycharm
                  cd d:/python_win/work/Blogs/test_blog_1

           В "git-bash.exe" переходим в нужную нам папку с проектом

            git init
            git add README.md (если не поставили галку README.md на GitHub)
            git commit -m "first commit"
            git remote add origin git@github.com:ник_на_ГитХабе/test.git
            git push -u origin master

            Если поставили галку на README.md или лицензии

                git init
                git remote add origin git@github.com:ник_на_ГитХабе/test.git
                git pull origin master

            Если мы добавим/изменим файл, то

                git add . (или git add --all)
                git commit -m "some commit"
                git push -u origin master

        8) Ошибки/Баги Gita:
            "src refspec master does not match any" - это значит что локальные файлы не соотвецтвуют файлам на ГитХабе.
            Нужно "обновиться" git pull origin master(branch-name), и только потом отправлять изменения на ГитХаб



        9) Cоздаем новый репозиторий

            Нажимаем на + вверху справа и у нас есть 2 варианта:

            1) Нажать галочку Initialize this repository with a README

            2) НЕ нажать галочку Initialize this repository with a README
            Переходим в консоле в папку с проектом

                echo "# flask_blog_1" >> README.md
                git init
                git add .
                git commit -m "init commit"
                git remote add origin git@github.com:<git_username>/<reponame>.git
                (это все вы сами увидите при выборе п.2)

                git push -u origin master





-------------------------------------------------------------------------------------------------------------------------------
    Имена:

        __mathodname__ - все специальные методы в пайтоне начинаються и заканчиваються двойным подчеркиванием

        _mathodname    - это внутренний метод но доступ к нему можно получить из вне. Также вызываеться через .mathodname











-------------------------------------------------------------------------------------------------------------------------------
Статические методы

    @staticmethod
    def smeth():
      тело функции
-------------------------------------------------------------------------------------------------------------------------------
Логирование ошибок в mod_python для Apache

mod_python.apache.log_error(error)
-------------------------------------------------------------------------------------------------------------------------------

Дата == timestamp в Python

    Дата в timestamp:

        t1=time.mktime(time.strptime('2000-01-01', '%Y-%m-%d'))

    Из timestamp в дату:

        t4=datetime.date.fromtimestamp(t1)

    Дата в нашем стандартном виде

        datetime.strftime(datetime.now(), '%d/%m/%Y')
-------------------------------------------------------------------------------------------------------------------------------
Минимальный фреймворк

flask

    доп. библиотека
            peewee
        или
            sqlalchemy

# на чистом питоне сайт написать можно.
# но все равно придется использовать инструменты не из коробки. тот же рендер для темплейтов например, работу с БД. какой-то мигратор для БД.
# для начала все таки посмотреть готовые фреймворки. примерно понять как они работают, оценить архитектуру, а потом можно писать и свой фреймворк

-------------------------------------------------------------------------------------------------------------------------------
Cookies

    Самый простой код для кук:
        #!/usr/bin/env python3
        print("Set-cookie: name=value; expires=Wed May 18 03:33:20 2033; path=/cgi-bin/; httponly")

        print("Content-type: text/html\n")
        print("Cookies!!!")

# срок действия до среды 18 мая 2033
# флаг httponly не позволит получать куку от JavaScript
# path=/cgi-bin/; говорит о том что повторный вызов куки могут запрашивать только скрипты из этой папки

Кука храниться в переменной-словаре os.environ (нужен import os) в виде ключ=значение, ключ ("HTTP_COOKIE")
Так же рекомендуется import http.cookies (почитать доки при работе с данной либой)
-------------------------------------------------------------------------------------------------------------------------------
Обработка исключений:

    try:
        if #kod

        else:
            #kod
    except Isklu4enie1:
        #kod
    except Isklu4enie2:
        #kod
    except (Isklu4enie3, Isklu4enie4):
        #kod
    except (Isklu4enie5 as exept):          #Isklu4enie5 доступно под именем  exept
        #kod
    except:                                 #перехват любого исключения
        #kod
    else:
        #kod                                #код если нет исключений
    finally:
        #kod                                #код который выполниться в любом случае


Исключения необходимо ловить начиная с узкоспециализированных (сверху) и переходить к более общим (внизу).
Обработчик except нужно указывать последним

Примеры:

    print("Calculator")

    a = 10
    b = 0

    try:
        print(a / b)
    except Exception as error:
        print(type(error))              #без type выведет текст ошибки а с type - ее тип
                                        # except Exception будет всегда отрабатывать так как он более общий
                                        # и должен находиться ниже ZeroDivisionError
    except ZeroDivisionError:
        print("delenie na nol")

    print('Stopping calculation.')


-------------------------------------------------------------------------------------------------------------------------------
Помощь/Справка/ Доп. функции

dir(sys) - она возвращает список имён, определённых в этом модуле. Если никакого аргумента не передавать, она вернёт список имён,
определённых в текущем модуле.

dir() # получим список атрибутов текущего модуля
        ['__builtins__', '__doc__', '__name__', '__package__', 'sys']




help("if")
help(int)

print(print.__doc__)
-------------------------------------------------------------------------------------------------------------------------------

Структура Пакетов

- <некоторый каталог из sys.path>/
| |---- world/
| |---- __init__.py
| |---- asia/
| | |---- __init__.py
| | |---- india/
| | |---- __init__.py
| | |---- foo.py
| |---- africa/
| |---- __init__.py
| |---- madagascar/
| |---- __init__.py
| |---- bar.py


-------------------------------------------------------------------------------------------------------------------------------

Перенос строки Windows  "\n"  или  "\r\n"
Перенос строки Unix     "\n"
-------------------------------------------------------------------------------------------------------------------------------
Пути  (path)

import os; print(os.getcwd()) - чтобы узнать текущий каталог программы.
-------------------------------------------------------------------------------------------------------------------------------

==============================================================================================================================
Виртуальное окружение virtualenv


    sudo apt-get install python3.7-venv
    
    python3.7 -m venv venv

    source venv/bin/activate 
    
    sudo apt-get install -y python3.7


    Активируем его source <your_venv-name>/bin/activate
    Чтобы выйти из виртуального окружения нужно прописать deactivate в консоле



==============================================================================================================================

Вопросы:

    - 0/1 можно записывать как True/False ?
    - как сравнивать типы (str, int) данных между собой ?
    - как правильно переносить строку кода или строку на следующую ?
    - как выглядит переменная константа ?
==============================================================================================================================

Ставим БД MySql

    sudo apt-get install mysql-server
        нас попросят ввести пароль для root БД (у меня 123)

    входим в консоль БД
        mysql -u root -p (вводим пароль для root БД (у меня 123))

    создаем Новую БД в правильной кодировке
        create database test1 character set utf8 collate utf8_unicode_ci;  (НЕ забываем в конце команд ";")

    exit - выход из консоли БД
==============================================================================================================================

    Модель MVC Flask

Model       = работа с database
View        = Controller (Django)
Controller
Templates   = View (Django)


Модули в Flask и Django

app        - в Django
blueprint - Flask (изолированый кусок функционального автономного кода = библиотека )



==============================================================================================================================

Переменные в .html файлах/шаблонах  {{peremenaya}}


==============================================================================================================================

Работа с БД в Flask через ORM (Object Relational ) sqlalchemy

# mysql-connector==2.1.4 нужен как драйвер для БД. От компании Oracle. Версия ==2.1.4 на 2017 год самая стабильная

pip install flask-sqlalchemy mysql-connector==2.1.4

Для записи в БД

db.session.add(peremennaya)
# или db.session.add_all([peremen1,peremen2])
db.session.commit()



Посмотреть все записи в БД

post = Post.query.all()
post


Фильтр поиска

ps = Post.query.filter(Post.title.contains('post'))
ps

p2 = Post.query.filter(Post.title.contains('second')).all()

p3 = Post.query.filter(Post.title=='!').all()
#нужно указать полное совпадение а не частичное

p3

p3 = Post.query.filter(Post.title=='Third post! 3-test').first()
p3

post1.count() - кол. объектов в переменной


BaseQuery

tags = db.relationship('Tag', secondary=post_tags, backref=db.backref('posts', lazy='dynamic'))


lazy='dynamic' - дает нам обращение к BaseQuery

dir(BaseQuery) или переменная со свойствами lazy='dynamic' для просмотра всех методов



==============================================================================================================================
Убить процессы python в ubuntu

pkill -9 python
==============================================================================================================================
Связи в БД

------------------------------------------------------------------------------
One-to-One

Tables

Post
                                    ForeignKey (FK)

    id      title   body    slug    tag_id

    1       Fist    1       first       3
    2       Second  2       second      4
    3       Third   2       third       5

Tag

    id      name   created_at
    3
    4
    5

Доп. примеры

http://docs.sqlalchemy.org/en/rel_0_9/orm/basic_relationships.html#one-to-one

https://stackoverflow.com/questions/28280507/setup-relationship-one-to-one-in-flask-sqlalchemy﻿
------------------------------------------------------------------------------

Many-to_Many

Нужно создать новую таблицу - таблицу связей

Tables

    Post-Tag

        post_id         tag_id

        1               1
        1               2
        1               3
        2               1
        2               1



====================================================================================================================


Веб-сервера для python:
Gunicorn работает с Django прямо из коробки. 
Вот более пристальный взгляд на шесть WSGI-серверов на рынке сегодня: 
- Bjoern, 
-uWSGI, 
-mod_wsgi, 
-Meinheld, 
-CherryPy 
-Gunicorn.