Вопросы на собеседованиях:

1. Стандартные типы данных:
    1) None (неопределенное значение переменной)
    2) Логические переменные (Boolean Type)
    3) Числа (Numeric Type)
        int – целое число
        float – число с плавающей точкой
        complex – комплексное число
    4) Массивы
        Списки (Sequence Type)
            list – список
            tuple – кортеж
            range – диапазон
        Множества (Set Types)
            set – множество
            frozenset – неизменяемое множество
        Словари (Mapping Types)
            dict – словарь

    5) Строки (Text Sequence Type )
        str
    6) Бинарные списки (Binary Sequence Types)
        bytes – байты
        bytearray – массивы байт
        memoryview – специальные объекты для доступа к внутренним данным объекта через protocol buffer

2. Разница между tuple и list
    list - изменяемый, массивный и тяжеловесный 
    tuple - не изменяемый, и легковестный 

3. Множества / set() - не упорядочный, не повторяющийся (список)

4. Стандартные библиотеки (sys, os, re, datetime)

5. PEP8

6. variable swap (x, y = y, x)

7. Разница между range() и xrange()
    Функция xrange() в Python очень похожа на функцию range() за тем лишь исключением, что вместо списка создает объект xrange. Производит те же элементы, что и range(), но не сохраняет их. Преимущества использования xrange() вместо range() заметны лишь при при работе с огромным количеством элементов или в ситуации, когда сами по себе созданные элементы нами не используются, нам не нужно изменять их или порядок в котором они расположены.
    В Python версии 3.х функция range() ведет себя как xrange() во второй версии питона, а функция xrange() убрана вовсе.

8. Минимальное значение в листе - пустота (None)

9. Удалить повторяющиеся элементы в листе
    def f(l):
    n = []
    for i in l:
        if not n or i != n[-1]:
            n.append(i)
    return n

11. Mutable:
        - словарь (dict),
        - список (list),
        - множество (set), 
    Immutable:
        - числа
        - строки
        - tuple

12. Менеджеры контекста (сраный with - as и cd тоже)
    любая функция содержащая методы
        __enter__ и __exit__ по умолчанию являються менеджерами контекста.

    https://youtu.be/_vxcRfjyfgk

13. Итераторы и генераторы
    Итератор – это интерфейс, который позволяет перебирать элементы последовательности. Он используется, например, в цикле for ... in ..., но этот механизм скрыт от глаз разработчика. При желании итератор можно получить "в сыром виде", воспользовавшись функцией iter().

    Чтобы получить следующий элемент коллекции или строки, нужно передать итератор функции next().
    Под капотом функциональность реализуется в методах __iter__ и __next__.

    На базе итераторов в языке появились новые элементы синтаксического сахара: выражения-генераторы и генераторы коллекций. Они позволяют устанавливать условия для отбора.
    Это простейший способ создать объект с интерфейсом итератора, при этом не загружая всех элементов в память (а это чаще всего и не нужно). 
    Основная фишка генератора в том, что он, подобно итератору, запоминает последний момент, когда к нему обращались, но при этом оперирует не абстрактными элементами, а вполне конкретными блоками кода. То есть если итератор по умолчанию будет перебирать элементы в контейнере, пока они не кончатся, то генератор будет гонять код, пока не выполнится какое-нибудь конкретное условие возврата.


14. yield - оператор, который возвращает управление программой.
    Не прерывает исполнение, а ставит "на паузу" и если это цикл, то он доходит снова до оператора yield.


16. Строки.
    r'C:\file.txt' - сырая строка
    ''' сохраняет форматирование и ничего не экранирует '''

17. Анонимные функции = lambda functions
    Лямбда-выражения
    Лямбды пришли в Python из языка Lisp.
    Это простые анонимные функции, записанные в одну строку.Их можно объявить даже там, где нельзя воспользоваться инструкцией def. Например, эти выражения часто используются в методах filter и map.

    foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
    print(list(map(lambda x: x * 2 + 10, foo)))
    # [14, 46, 28, 54, 44, 58, 26, 34, 64] 

18. Шаблоны проектирования (Singleton, Decorator, etc)
    
    Декораторы.
    Смысл паттерна Декоратор заключается в том, что некоторая функция заворачивается в другую функцию, приобретая от нее новые возможности. Например, так можно вести логи, вводить пред- и постусловия, добавлять методы для классов.
    Декораторы в Python – это, по сути, синтаксический сахар. Для их обозначения используется символ @.
    В Python есть несколько встроенных декораторов, например, @classmethod, @staticmethod, @property.

    Singleton – это паттерн, предназначенный для того, чтобы ограничивать количество экземпляров, которые могут быть использованы одним классом. Также этот паттерн позволяет расшаривать один и тот же объект среди многих других частей кода. Это позволяет использовать глобальные переменные, поскольку фактически используемые данные скрыты интерфейсом класса singleton. Интерфейс класса singleton имеет только один публичный член класса и один метод этого класса Handle. 
    Singleton::Handle()

19. Магические методы
    __маг_метод__

20. Sync and wait (python 3.5)
    
21. Плюсы и минусы множественного наследования (это зло)
22. New style and old style classes
23. MRO (Method Resolution Order)
    python3 использует алгоритм С3 для Методов организации разрешений.
    Можно использовать mro() метод

24. _slots_
    Ограничивает кол. атрибутов и удаляет __dict__ у объекта
    + namedtuple
    https://habr.com/ru/post/330034/

25. Дескриптор протокола
    Дескрипторы – это объекты с любыми __get__ , __set__ или __delete__ . Эти объекты дескриптора могут использоваться как атрибуты для других определений классов объектов.

27. Metaclasses
28. Функция type()
29. Ассинхронность:
    1) callback
    2) generators | coroutin
    3) async / await
30. Изменяемые (mutable) и неизменяемые (immutable) типы данных:
    1) Не изменяемые: числа, строки и кортежи.
    2) Список, словарь


31. Исключения.
    В Питоне определен главный класс BaseException, от которого наследуются все остальные классы ошибок. У него есть 4 прямых наследника:

    SystemExit – произошел выход из программы.
    KeyboardInterrupt – пользователь прервал выполнение программы (комбинация Ctrl+C).
    GeneratorExit – завершена работа объекта generator.
    Exception – родительский класс для пользовательских исключений.

32. Что такое SOLID?
    введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином[1][2] в начале 2000-х[3], которые означали пять основных принципов объектно-ориентированного программирования и проектирования.

    S - Принцип единственной ответственности (The Single Responsibility Principle).
        Каждый класс должен иметь одну и только одну причину для изменений.
    O - Принцип открытости/закрытости (The Open Closed Principle)
        «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»
    L - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)
        «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» Наследующий класс должен дополнять, а не изменять базовый.
    I - Принцип разделения интерфейса (The Interface Segregation Principle)
        «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
    D - Принцип инверсии зависимостей (The Dependency Inversion Principle)
        «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»

    KISS (акроним для «Keep it simple, stupid») — принцип проектирования, принятый в ВМС США в 1960. 
    Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.

    YAGNI («You aren't gonna need it»; с англ. — «Вам это не понадобится») — процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности.

33. REST (сокращение от англ. Representational State Transfer — «передача состояния представления») 
    — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. 

    Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTfull».

    Требования к архитектуре REST:
    1. Модель клиент-сервер.
        Отделение потребности интерфейса клиента от потребностей сервера, хранящего данные, повышает переносимость кода клиентского интерфейса на другие платформы, а упрощение серверной части улучшает масштабируемость. 

    2. Отсутствие состояния.
        Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента.

    3. Кэширование.

    4. Единообразие интерфейса.
        
        К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия:
        1) Идентификация ресурсов
            Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера.
        2) Манипуляция ресурсами через представление
            Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.
        3) «Самоописываемые» сообщения
            Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать.
        4) Гипермедиа как средство изменения состояния приложения
            Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу

    5. Слои
        Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования.

    6. Код по требованию (необязательное ограничение)
        REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера

34. В чем разница между аутентификацией и авторизацией?
    
    Аутентификация - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.

    Авторизация - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла) в соответствии с ранее выполненной аутентификацией

35. Что такое new()? И чем он отличается от init()? В какой последовательности они выполняются?
    
    Используйте __new__, когда вам нужно контролировать создание нового экземпляра.
    Используйте __init__, когда вам нужно контролировать инициализацию нового экземпляра.

    __new__ - это первый шаг создания экземпляра. Сначала он вызывается и отвечает за возврат нового экземпляра вашего класса.
    Напротив, __init__ ничего не возвращает; он отвечает только за инициализацию экземпляра после его создания.

    В общем, вам не нужно переопределять __new__, если вы не наследуете неизменяемый тип, такой как str, int, unicode или tuple.

- list comprehantion
- slice [-1, 2, 10]
- наследование --> плохо ? 
- singletone



https://proglib.io/p/python-interview/


Задачки

1) https://pythonworld.ru/osnovy/tasks.html
2)
