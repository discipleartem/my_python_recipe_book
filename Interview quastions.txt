Вопросы на собеседованиях:

1. Стандартные типы данных
2. Разница между туплами и листами
3. Множества (set)
4. Стандартные библиотеки (sys, os, re, datetime)
5. PEP8
6. variable swap (x, y = y, x)
7. Разница между range() и xrange()
8. Минимальное значение в листе
9. Удалить повторяющиеся элементы в листе
10. str.split() 
11. Mutable and immutable types
12. Менеджеры контекста (сраный with)
13. Итераторы и генераторы
    Итератор – это интерфейс, который позволяет перебирать элементы последовательности. Он используется, например, в цикле for ... in ..., но этот механизм скрыт от глаз разработчика. При желании итератор можно получить "в сыром виде", воспользовавшись функцией iter().

    Чтобы получить следующий элемент коллекции или строки, нужно передать итератор функции next().
    Под капотом функциональность реализуется в методах __iter__ и __next__.

    На базе итераторов в языке появились новые элементы синтаксического сахара: выражения-генераторы и генераторы коллекций. Они позволяют устанавливать условия для отбора.
    Очевидно, что генераторы могут выполнять работу функций map и filter. Более того, они справляются с этой задачей эффективнее.

14. yield

15. Разница между методом класса и статическим методом

16. Строки.
    r'C:\file.txt' - сырая строка
    ''' сохраняет форматирование и ничего не экранирует '''

17. Анонимные функции = lambda functions
    Лямбда-выражения
    Лямбды пришли в Python из языка Lisp.
    Это простые анонимные функции, записанные в одну строку.Их можно объявить даже там, где нельзя воспользоваться инструкцией def. Например, эти выражения часто используются в методах filter и map.

    foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
    print(list(map(lambda x: x * 2 + 10, foo)))
    # [14, 46, 28, 54, 44, 58, 26, 34, 64] 

18. Шаблоны проектирования (Singleton, Decorator, etc)
    
    Декораторы.
    Смысл паттерна Декоратор заключается в том, что некоторая функция заворачивается в другую функцию, приобретая от нее новые возможности. Например, так можно вести логи, вводить пред- и постусловия, добавлять методы для классов.
    Декораторы в Python – это, по сути, синтаксический сахар. Для их обозначения используется символ @.
    В Python есть несколько встроенных декораторов, например, @classmethod, @staticmethod, @property.

    Singleton – это паттерн, предназначенный для того, чтобы ограничивать количество экземпляров, которые могут быть использованы одним классом. Также этот паттерн позволяет расшаривать один и тот же объект среди многих других частей кода. Это позволяет использовать глобальные переменные, поскольку фактически используемые данные скрыты интерфейсом класса singleton. Интерфейс класса singleton имеет только один публичный член класса и один метод этого класса Handle. 
    Singleton::Handle()

19. Магические методы
20. Sync and wait (python 3.5)
21. Плюсы и минусы множественного наследования (это зло)
22. New style and old style classes
23. MRO
24. _slots_
25. Дескриптор протокола
26. Multiprocessing and threading
27. Metaclasses
28. Функция type()
29. Ассинхронность:
    1) callback
    2) generators | coroutin
    3) async / await
30. Изменяемые (mutable) и неизменяемые (immutable) типы данных:
    1) Не изменяемые: числа, строки и кортежи.
    2) Список, словарь


31. Исключения.
    В Питоне определен главный класс BaseException, от которого наследуются все остальные классы ошибок. У него есть 4 прямых наследника:

    SystemExit – произошел выход из программы.
    KeyboardInterrupt – пользователь прервал выполнение программы (комбинация Ctrl+C).
    GeneratorExit – завершена работа объекта generator.
    Exception – родительский класс для пользовательских исключений.

32. Что такое SOLID?
    введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином[1][2] в начале 2000-х[3], которые означали пять основных принципов объектно-ориентированного программирования и проектирования.

    S - Принцип единственной ответственности (The Single Responsibility Principle).
        Каждый класс должен иметь одну и только одну причину для изменений.
    O - Принцип открытости/закрытости (The Open Closed Principle)
        «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»
    L - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)
        «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» Наследующий класс должен дополнять, а не изменять базовый.
    I - Принцип разделения интерфейса (The Interface Segregation Principle)
        «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
    D - Принцип инверсии зависимостей (The Dependency Inversion Principle)
        «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»

    KISS (акроним для «Keep it simple, stupid») — принцип проектирования, принятый в ВМС США в 1960. 
    Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.

    YAGNI («You aren't gonna need it»; с англ. — «Вам это не понадобится») — процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности.

33. REST (сокращение от англ. Representational State Transfer — «передача состояния представления») 
    — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. 

    Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTfull».

    Требования к архитектуре REST:
    1. Модель клиент-сервер.
        Отделение потребности интерфейса клиента от потребностей сервера, хранящего данные, повышает переносимость кода клиентского интерфейса на другие платформы, а упрощение серверной части улучшает масштабируемость. 

    2. Отсутствие состояния.
        Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента.

    3. Кэширование.

    4. Единообразие интерфейса.
        
        К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия:
        1) Идентификация ресурсов
            Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера.
        2) Манипуляция ресурсами через представление
            Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.
        3) «Самоописываемые» сообщения
            Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать.
        4) Гипермедиа как средство изменения состояния приложения
            Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу

    5. Слои
        Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования.

    6. Код по требованию (необязательное ограничение)
        REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера

34. В чем разница между аутентификацией и авторизацией?
    
    Аутентификация - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.

    Авторизация - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла) в соответствии с ранее выполненной аутентификацией

35. 

- list comprehantion
- slice [-1, 2, 10]
- наследование --> плохо ? 
- singletone



https://proglib.io/p/python-interview/


Задачки

1) https://pythonworld.ru/osnovy/tasks.html
2)
